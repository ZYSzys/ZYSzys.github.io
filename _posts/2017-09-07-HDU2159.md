---
layout: post
category: ACM
tags:
  - DP
title: HDU 2159 FATE
---

[HDU 2159 FATE](http://acm.hdu.edu.cn/showproblem.php?pid=2159)

DP, 类似完全背包问题  
状态转移方程：dp[i][j] = max(dp[i][j], dp[i-g[t].b][j-1]+g[t].a)表示在i的忍耐度下杀掉j个怪所能得到的最多经验

<!--more-->
## 代码：
```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 110;
struct Moni
{
    int a, b;
}g[N];
int dp[N][N];
int main()
{
    int n, m, k, s;
    while(~scanf("%d%d%d%d", &n, &m, &k, &s))
    {
        for(int i = 1; i <= k; i++)
        {
            scanf("%d%d", &g[i].a, &g[i].b);
        }
        memset(dp, 0, sizeof(dp));
        for(int t = 1; t <= k; t++)
        {
            for(int i = g[t].b; i <= m; i++)
            {
                for(int j = 1; j <= s; j++)
                {
                    dp[i][j] = max(dp[i][j], dp[i-g[t].b][j-1]+g[t].a);
                }
            }
        }
        if(dp[m][s] < n)
        {
            printf("-1\n");
        }
        else
        {
            for(int i = 1; i <= m; i++)
            {
                if(dp[i][s] >= n)
                {
                    printf("%d\n", m-i);
                    break;
                }
            }
        }
    }
    return 0;
}
```

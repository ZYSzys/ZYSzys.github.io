---
layout: post
category: ACM
title: 正方形划分
tags: DFS
---


<!--more-->



用a[i][j] 表示从1,1坐标到i j的矩形中有多少个点 
则暴力i j以及变成k  可以求出所有的正方形 如果正方形中只含有1个点 就把这个正方形分出来 可以用1去标记下   把正方形全部标记为1 
然后DFS回溯到正确的解（因为分法不同结果就不一样了，回溯只要有一个正确的解就可以了）
 
一开始自己的思路是正确的     也是用一样的方法去找这样的含一个点的正方形  分不知道怎么分  分法不同 结果就不一样了   居然没有想到用DFS回溯  简直就是个# 加油 今天又进步了点
 
 
```c++
#include <cstdio>
#include <cstring>
const int N = 25;
int a[N][N], mp[N][N];
bool vis[N][N];
int l, n;
bool DFS()
{
    bool flag = true;
    int x, y;
    for(int i = 1; i <= l && flag; i++)
    {
        for(int j = 1; j <= l && flag; j++)
        {
            if(!vis[i][j])
            {
                x = i, y = j, flag = false;
            }
        }
    }
    if(flag)
        return true;
    for(int k = 0; k+x <= l && k+y <= l; k++)
    {
        int nx = k + x, ny = k + y;
        int cnt = a[nx][ny] - a[nx][y-1] - a[x-1][ny] + a[x-1][y-1];
        if(cnt >= 2)
            break;
        if(cnt == 1)
        {
            for(int i = x; i <= nx; i++)
                for(int j = y; j <= ny; j++)
                    vis[i][j] = true;
            if(DFS())
                return true;
            for(int i = x; i <= nx; i++)
                for(int j = y; j <= ny; j++)
                    vis[i][j] = false;
        }
    }
    for(int i = 1; i <= l; i++)
    {
        for(int j = 1; j <= l; j++)
        {
            if(!vis[i][j])
                return false;
        }
    }
    return true;
}
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
        scanf("%d%d", &l, &n);
        memset(a, 0, sizeof(a));
        memset(mp, 0,sizeof(mp));
        memset(vis, false, sizeof(vis));
        for(int i = 0; i < n; i++)
        {
            int r, c;
            scanf("%d%d", &r, &c);
            mp[r][c] = 1;
        }
        for(int i = 1; i <= l; i++)
        {
            for(int j = 1; j <= l; j++)
            {
                a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + mp[i][j];
            }
        }
        printf("%s\n", DFS()?"YES":"NO");
    }
    return 0;
}
```


<p>看看以下这段代码：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="n">Foo</span> <span class="o">*</span><span class="n">pnext</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo_bar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">bar</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bar</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span> <span class="n">bar</span><span class="p">.</span><span class="n">pnext</span> <span class="p">)</span>
        <span class="c1">// ... do somthing
</span>    <span class="c1">// ...
</span><span class="p">}</span>
</code></pre>
</div>

<p>上述程序并不会合成出一个 default constructor。什么时候会合成出 default constructor 呢，下面分4种情况。</p>

<!--more-->

<h2 id="带有-default-constructor-的-memeber-class-object">带有 Default Constructor 的 Memeber Class Object</h2>

<p>编译器需要为该 class 合成一个 default constructor，不过这个合成操作只有在 constructor 真正需要被调用时才会发生。</p>

<p>合成的 default constructor、copy constructor、destructor、assignment copy operator 都以<code class="highlighter-rouge">inline</code>方式完成，如果函数太复杂，不适合做成<code class="highlighter-rouge">inline</code>，就会合成出 explicit non-inline static 实例。</p>

<p>举个例子：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">Foo</span><span class="p">();</span> <span class="n">Foot</span><span class="p">(</span><span class="kt">int</span> <span class="p">)</span> <span class="p">...</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo_bar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><img src="http://simpleyyt.qiniudn.com/15-9-22/65375122.jpg" alt="对象关系" /></p>

<p>编译器会为<code class="highlighter-rouge">class Bar</code>合成一个 default constructor 来处理 <code class="highlighter-rouge">Bar::foo</code>，但它并不初始化<code class="highlighter-rouge">Bar::str</code>。</p>

<p>合成的 default constructor 可能像这样：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kr">inline</span>
<span class="n">Bar</span><span class="o">::</span><span class="n">Bar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>假设程序员提供了 default constructor：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Bar</span><span class="o">::</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">str</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</code></pre>
</div>

<p>则编译器会扩张已存在的 constructors：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Bar</span><span class="o">::</span><span class="n">Bar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">();</span>
    <span class="n">str</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>如果有多个 class member objects 都要求 constructor 初始化操作，C++ 语言将以 <strong>member objects 在 class 中的声明顺序</strong>来调用各个 constructors。</p>

<h2 id="带有-default-constructor-的-base-class">带有 Default Constructor 的 Base Class</h2>

<p>将会合成 Default Constructor，会根据 base class 声明的顺序调用 base class 的 default constructor。</p>

<p>如果有多个 constructors，编译器会扩张现有的每一个 constructors。</p>

<h2 id="带有一个-virtual-function-的-class">带有一个 Virtual Function 的 Class</h2>

<p>以下两种情况，也需要合成出 default constructor：</p>

<blockquote>
  <ol>
    <li>class 声明（或继承）一个 virtual function。</li>
    <li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes。</li>
  </ol>
</blockquote>

<p>举个例子：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">flip</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">flip</span><span class="p">(</span> <span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">widget</span> <span class="p">)</span> <span class="p">{</span> <span class="n">widget</span><span class="p">.</span><span class="n">flip</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bell</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">Whistle</span> <span class="n">w</span><span class="p">;</span>
    
    <span class="n">flip</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">flip</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p><img src="http://simpleyyt.qiniudn.com/15-9-22/58211208.jpg" alt="类图" /></p>

<p>编译期间发生两个扩张：</p>

<blockquote>
  <ol>
    <li>virtual function table</li>
    <li>pointer member （也就是 vptr ）</li>
  </ol>
</blockquote>

<p><code class="highlighter-rouge">flip</code> 函数可能被改写如下：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">(</span> <span class="o">*</span><span class="n">widget</span><span class="p">.</span><span class="n">vptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)(</span> <span class="o">&amp;</span><span class="n">widget</span> <span class="p">)</span>
</code></pre>
</div>

<p>为了让这个机制发挥功效，编译器必须为每一个 Widget（或其派生类）object 的 vptr 设置初值，放置适当的 virtual table 地址。对于 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情，如果没有 construcotr，则合成一个。</p>

<h2 id="带有一个-virtual-base-class-的-class">带有一个 Virtual Base Class 的 Class</h2>

<p>例如以下代码：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">X</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">X</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">double</span> <span class="n">d</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">,</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">k</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">*</span> <span class="n">pa</span><span class="p">)</span> <span class="p">{</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="p">}</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">);</span>
    <span class="n">foo</span><span class="p">(</span><span class="k">new</span> <span class="n">C</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p><code class="highlighter-rouge">foo()</code>可能被改写如下：</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">*</span> <span class="n">pa</span><span class="p">)</span> <span class="p">{</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">_vbcX</span><span class="o">-&gt;</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="p">}</span>
</code></pre>
</div>

<p>class 所定义的每一个 constructor，编译器会安插代码来初始化<code class="highlighter-rouge">_vbcX</code>，如果没有 constructors，编译器必须合成一个 default constructor。</p>

<h2 id="总结">总结</h2>

<p>C++ 新手一般有两个常见的误解：</p>

<blockquote>
  <ol>
    <li>任何 class 如果没有定义 default constructor，就会被合成出一个来。</li>
    <li>编译器合成出来的 default constructor 会显式设定 class 内每一个 data member 的默认值。</li>
  </ol>
</blockquote>

<p>如你所见，没有一个是真的。</p>


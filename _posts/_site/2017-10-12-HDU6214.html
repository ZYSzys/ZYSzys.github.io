<p><a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=6214">HDU 6214 Smallest Minimum Cut</a></p>

<p>最大流Dinic算法，将每条边的w转化为原来的mod倍+1, 最后跑一遍最大流Dinic，maxflow对mod取模就是所求答案
<!--more--></p>
<h1 id="smallest-minimum-cut">Smallest Minimum Cut</h1>

<p>Time Limit: 2000/2000 MS (Java/Others)    Memory Limit: 65535/32768 K (Java/Others)
Total Submission(s): 1767    Accepted Submission(s): 697</p>

<h2 id="problem-description">Problem Description</h2>
<p>Consider a network G=(V,E) with source s and sink t. An s-t cut is a partition of nodes set V into two parts such that s and t belong to different parts. The cut set is the subset of E with all edges connecting nodes in different parts. A minimum cut is the one whose cut set has the minimum summation of capacities. The size of a cut is the number of edges in the cut set. Please calculate the smallest size of all minimum cuts.</p>

<h3 id="input">Input</h3>
<p>The input contains several test cases and the first line is the total number of cases T (1≤T≤300).
Each case describes a network G, and the first line contains two integers n (2≤n≤200) and m (0≤m≤1000) indicating the sizes of nodes and edges. All nodes in the network are labelled from 1 to n.
The second line contains two different integers s and t (1≤s,t≤n) corresponding to the source and sink.
Each of the next m lines contains three integers u,v and w (1≤w≤255) describing a directed edge from node u to v with capacity w.</p>

<h3 id="output">Output</h3>
<p>For each test case, output the smallest size of all minimum cuts in a line.</p>

<h3 id="sample-input">Sample Input</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>2
4 5
1 4
1 2 3
1 3 1
2 3 1
2 4 1
3 4 2
4 5
1 4
1 2 3
1 3 1
2 3 1
2 4 1
3 4 3
</code></pre>
</div>

<h3 id="sample-output">Sample Output</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>2
3
</code></pre>
</div>

<h2 id="代码">代码</h2>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;bits/stdc++.h&gt;  
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>  
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>  
<span class="k">const</span> <span class="kt">int</span> <span class="n">MOD</span><span class="o">=</span><span class="mi">100000</span><span class="p">;</span>  
<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span><span class="o">=</span><span class="mh">0x3f3f3f3f</span><span class="p">;</span>  
<span class="k">struct</span> <span class="n">edge</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">to</span><span class="p">,</span><span class="n">cap</span><span class="p">,</span><span class="n">rev</span><span class="p">;</span>  
    <span class="n">edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span><span class="kt">int</span> <span class="n">z</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">to</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">cap</span><span class="o">=</span><span class="n">y</span><span class="p">;</span><span class="n">rev</span><span class="o">=</span><span class="n">z</span><span class="p">;</span>  
    <span class="p">}</span>  
<span class="p">};</span>  
<span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>  
<span class="kt">int</span> <span class="n">level</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">iter</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>  
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>  
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span><span class="kt">int</span> <span class="n">to</span><span class="p">,</span><span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">g</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">(</span><span class="n">to</span><span class="p">,</span><span class="n">cap</span><span class="p">,</span><span class="n">g</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">size</span><span class="p">()));</span>  
    <span class="n">g</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">g</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>  
<span class="p">}</span>  
<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">memset</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">level</span><span class="p">));</span>  
    <span class="n">level</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>  
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>  
    <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>  
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">=</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>  
            <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">cap</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  
                <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span><span class="kt">int</span> <span class="n">f</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==</span><span class="n">t</span><span class="p">)</span><span class="k">return</span> <span class="n">f</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">=</span><span class="n">iter</span><span class="p">[</span><span class="n">v</span><span class="p">];</span><span class="n">i</span><span class="o">&lt;</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">=</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>  
        <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">cap</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&gt;</span><span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>  
        <span class="p">{</span>  
            <span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">cap</span><span class="p">));</span>  
            <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="n">e</span><span class="p">.</span><span class="n">cap</span><span class="o">-=</span><span class="n">d</span><span class="p">;</span>  
                <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">].</span><span class="n">cap</span><span class="o">+=</span><span class="n">d</span><span class="p">;</span>  
                <span class="k">return</span> <span class="n">d</span><span class="p">;</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">max_flow</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">int</span>  <span class="n">flow</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">bfs</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  
        <span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="k">return</span> <span class="n">flow</span><span class="p">;</span>  
        <span class="n">memset</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>  
        <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>  
        <span class="k">while</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">INF</span><span class="p">))</span>  
        <span class="p">{</span>  
            <span class="n">flow</span><span class="o">+=</span><span class="n">f</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">TA</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>  
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">TA</span><span class="p">);</span>  
    <span class="k">while</span><span class="p">(</span><span class="n">TA</span><span class="o">--</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>  
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>  
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>  
            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="o">*</span><span class="n">MOD</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  
            <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>  
        <span class="p">}</span>  
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">max_flow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="o">%</span><span class="n">MOD</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre>
</div>


<p>《C++ Primer》笔记，整理关于函数重载与函数匹配的笔记。</p>

<!--more-->

<h2 id="函数重载">函数重载</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//原函数
</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//正确：形参类型不同
</span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 正确：形参个数不同
</span><span class="kt">int</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//错误：只有返回类型不同
</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">int32</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">int32</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//与原函数等价：形参类型相同
</span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//与原函数等价：顶层 const 将被忽略
</span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//与原函数等价：只是省略了形参名字
</span></code></pre>
</div>

<p><strong>函数重载有如下的规则：</strong></p>

<ul>
  <li>名字相同，形参类型不一样。</li>
  <li>不允许两个函数除了返回类型外其他所有的要素都相同。</li>
  <li>顶层<code class="highlighter-rouge">const</code>的形参无法和没有顶层<code class="highlighter-rouge">const</code>的形参区分。</li>
</ul>

<p>其中返回类型不同时编译时会出错，而类型别名、项层<code class="highlighter-rouge">const</code>、省略形参名字只是重复声明而已，只要不定义，编译就不会出错，比如：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">//只定义了其中一个
</span><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</code></pre>
</div>

<h2 id="函数匹配">函数匹配</h2>

<h3 id="名字查找">名字查找</h3>

<p>函数匹配的第一步便是<strong>名字查找（name lookup）</strong>，确定<strong>候选函数</strong>。</p>

<p>名字查找有两方面：</p>

<ul>
  <li>常规查找（normal lookup）</li>
  <li>实参决定的查找（argument-dependent lookup，ADL）</li>
</ul>

<p>所有函数调用都会进行常规查找，只有函数的实参包括类类型对象或指向类类型对象的指针/引用的时候，才会进行实参决定的查找。</p>

<p><strong>常规查找</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>	<span class="c1">//1
</span><span class="k">namespace</span> <span class="n">N</span>
<span class="p">{</span>
	<span class="c1">//作用域
</span>	<span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{}</span>	<span class="c1">//2
</span>	<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>	<span class="c1">//3
</span>	<span class="p">...</span>
	<span class="kt">void</span> <span class="n">test1</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">func</span><span class="p">();</span> <span class="c1">//候选函数为函数2和3
</span>	<span class="p">}</span>
	
	<span class="kt">void</span> <span class="n">test2</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">using</span> <span class="o">::</span><span class="n">func</span><span class="p">;</span> <span class="c1">//将函数1加入当前作用域
</span>		<span class="n">func</span><span class="p">();</span> <span class="c1">//候选函数为函数1
</span>	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>从函数被调用的局部作用域开始，逐渐向上层寻找被调用的名字，一旦找到就停止向上寻找，将找到的所有名字加入候选函数。</p>

<p>此外，using语句可以将其他作用域的名字引用到当前作用域。</p>

<p><strong>ADL查找</strong></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//1
//第一个实参所在命名空间
</span><span class="k">namespace</span> <span class="n">Name1</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">T</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//2
</span>    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//3
</span><span class="p">}</span>
<span class="c1">//第二个实参的间接父类所在命名空间
</span><span class="k">namespace</span> <span class="n">Name00</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">T00</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//4
</span>    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//5
</span><span class="p">}</span>
<span class="c1">//第二个实参父类所在命名空间
</span><span class="k">namespace</span> <span class="n">Name0</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">T0</span><span class="o">:</span><span class="k">public</span> <span class="n">Name00</span><span class="o">::</span><span class="n">T00</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//6
</span>    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">//7
</span><span class="p">}</span>
<span class="c1">//第二个实参所在命名空间
</span><span class="k">namespace</span> <span class="n">Name2</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">T</span><span class="o">:</span><span class="k">public</span> <span class="n">Name0</span><span class="o">::</span><span class="n">T0</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//8
</span>    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//9
</span><span class="p">}</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Name1</span><span class="o">::</span><span class="n">T</span> <span class="n">t1</span><span class="p">;</span>
    <span class="n">Name2</span><span class="o">::</span><span class="n">T</span> <span class="n">t2</span><span class="p">;</span>
    <span class="c1">//9个函数全是候选函数  
</span>    <span class="c1">//第1个函数是normal lookup找到的
</span>    <span class="c1">//后8个函数全是argument-dependent lookup找到的
</span>    <span class="n">func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>从第一个类类型参数开始，依次遍历所有类类型参数。对于每一个参数，进入其类型定义所在的作用域（类内友元函数也包括在内），并依次进入其基类、间接基类……定义所在的作用域，查找同名函数，并加入候选函数。</p>

<p><strong>注意：</strong>在继承体系中上升的过程中，不会因为找到同名函数就停止上升，这不同于常规查找。</p>

<p>类中的运算符重载也遵循 ADL 查找，其候选函数集既包括成员函数，也应该包括非成员函数。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">N</span>
<span class="p">{</span>
	<span class="k">class</span> <span class="nc">A</span>
	<span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="kt">void</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//1
</span>	<span class="p">};</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//2
</span><span class="p">};</span>
<span class="kt">void</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//3
</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">N</span><span class="o">::</span><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//1、2、3都是候选函数
</span><span class="p">}</span>
</code></pre>
</div>

<h3 id="确定可行函数">确定可行函数</h3>

<p>第二步便是从候选函数中选出可行函数，选择的标准如下：</p>

<ul>
  <li>形参数量与本次调用提供的实参数量相等</li>
  <li>每个实参的类型与对应的形参类型相同，或者能转换成形参类型</li>
</ul>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">//以下为候选函数
</span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//可行函数
</span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//可行函数：实参可转化成形参类型
</span><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//可行函数
</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//非可行函数：形参数量不匹配
</span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">[])</span> <span class="p">{}</span> <span class="c1">//非可行函数：实参不能转换成形参
</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="寻找最佳匹配">寻找最佳匹配</h3>

<p>从可行函数中选择最匹配的函数，如果有多个形参，则最佳匹配条件为：</p>

<ul>
  <li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>
  <li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>
</ul>

<p>否则，发生二义性调用错误。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">//可行函数
</span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span> <span class="c1">//二义性错误：double 向 int 的转换与向 float 的转换一样好
</span>	<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//调用 void func(int a, int b)
</span><span class="p">}</span>
</code></pre>
</div>

<p>为了确定最佳匹配，实参类型到形参类型的转换等级如下：</p>

<ol>
  <li>精确匹配：
    <ul>
      <li>实参类型和形参类型相同。</li>
      <li>实参从数组类型或函数类型转换成对应的指针类型。</li>
      <li>向实参添加顶层<code class="highlighter-rouge">const</code>或者从实参中删除顶层<code class="highlighter-rouge">const</code>。</li>
    </ul>
  </li>
  <li>通过<code class="highlighter-rouge">const</code>转换实现的匹配。</li>
  <li>通过类型提升实现的匹配。</li>
  <li>通过算术类型转换或指针转换实现的匹配。</li>
  <li>通过类类型转换实现的匹配。</li>
</ol>

<p><em>一般不会存在这个阶段不会同时存在两个以上的精确匹配，因为两个精确的匹配在本质上是等价的，在定义重载函数时，编译器可能就报出重定义的错误了。</em></p>

<p>挑几个重点的来详细说一下。</p>

<p><strong>指针转换实现的匹配</strong></p>

<ul>
  <li>0 或<code class="highlighter-rouge">nullptr</code>能转换成任意指针类型。</li>
  <li><code class="highlighter-rouge">T *</code> 能转换成 <code class="highlighter-rouge">void *</code>，<code class="highlighter-rouge">const void *</code>转换成<code class="highlighter-rouge">const void*</code>。</li>
  <li>派生类向基类类型的转换。</li>
  <li>函数与函数指针的形参类型必须精确匹配。</li>
</ul>

<p><strong>类类型转换实现的匹配</strong></p>

<p>两个类型提供相同的类型转换将产生二义性问题。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">B</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
	<span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span>	<span class="c1">//把一个 B 转换成 A
</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
	<span class="k">operator</span> <span class="n">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 也是把一个 B 转换成 A
</span><span class="p">};</span>

<span class="n">A</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>

<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">//二义性错误：f(B::operator A()) 还是 f(A::A(const B&amp;))
</span>
<span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span> <span class="c1">//正确：使用 B 的类型转换运算
</span><span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">//正确：使用 A 的构造函数
</span></code></pre>
</div>

<p>类当中定义了多个参数都是算术类型的构造函数或类型转换运算符，也会产生二义性问题。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
	<span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
	<span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
	<span class="k">operator</span> <span class="kt">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>

<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">//二义性错误：f(A::operator int()) 还是 f(A::operator double())？
</span>
<span class="kt">long</span> <span class="n">l</span><span class="p">;</span>
<span class="n">A</span> <span class="n">a2</span><span class="p">(</span><span class="n">l</span><span class="p">);</span> <span class="c1">//二义性错误：A::A(int) 还是 A::A(double)？
</span>
<span class="kt">short</span> <span class="n">s</span><span class="p">;</span>
<span class="n">A</span> <span class="n">a3</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">//正确：使用 A::A(int)
</span></code></pre>
</div>

<p>当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。</p>

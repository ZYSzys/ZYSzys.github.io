<p>C++ 有插入迭代器、流迭代器、反向迭代器、移动迭代器，泛型算法结构有适用的迭代器类别：输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。</p>

<!--more-->

<h2 id="再探迭代器">再探迭代器</h2>

<p><strong>迭代器</strong>:</p>

<ul>
  <li>插入迭代器</li>
  <li>流迭代器</li>
  <li>反向迭代器</li>
  <li>移动迭代器</li>
</ul>

<h3 id="插入迭代器">插入迭代器</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">it</span> <span class="o">=</span> <span class="n">t</span> <span class="c1">//在it指定的当前位置插入值t。
</span><span class="o">*</span><span class="n">it</span><span class="err">，</span><span class="o">++</span><span class="n">it</span><span class="p">,</span><span class="n">it</span><span class="o">++</span> <span class="c1">//不会做任何事情，都返回it
</span></code></pre>
</div>
<ul>
  <li><strong><code class="highlighter-rouge">back_inserter</code></strong>: <code class="highlighter-rouge">push_back</code>的迭代器</li>
  <li><strong><code class="highlighter-rouge">front_inserter</code></strong>: <code class="highlighter-rouge">push_front</code>的迭代器</li>
  <li><strong><code class="highlighter-rouge">inserter</code></strong>: 第二个参数指向给定容器的迭代器</li>
</ul>

<h3 id="流迭代器">流迭代器</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">(</span><span class="n">is</span><span class="p">);</span> <span class="c1">//in从输入流is读取类型为T的值
</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">;</span>    <span class="c1">//读取类型为T的值istream_iterator迭代器，表示尾后位置
</span><span class="n">in1</span> <span class="o">==</span> <span class="n">in2</span>  <span class="c1">//in1和in2必须读取相同类型
</span><span class="n">in1</span> <span class="o">!=</span> <span class="n">in2</span>
<span class="o">*</span><span class="n">in</span> <span class="c1">//返回从流中读取的值
</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">mem</span>
<span class="o">++</span><span class="n">in</span><span class="p">,</span> <span class="n">in</span><span class="o">++</span>
</code></pre>
</div>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">ostream_itertor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> 
<span class="n">out</span> <span class="o">=</span> <span class="n">val</span>
<span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="o">++</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">++</span> <span class="c1">//不做任何事
</span></code></pre>
</div>

<p>可以为任何定义了输入运算符(»)的类型创建<code class="highlighter-rouge">istream_iterator</code>对象，类似的(«)可以创建<code class="highlighter-rouge">ostream_iterator</code>对象。</p>

<h3 id="反向迭代器">反向迭代器</h3>

<blockquote>
  <p><code class="highlighter-rouge">rbegin</code>、<code class="highlighter-rouge">rend</code>、<code class="highlighter-rouge">crbegin</code>、<code class="highlighter-rouge">crend</code></p>
</blockquote>

<p><strong>反向迭代器需要递减运算符</strong></p>

<p>不可能从一个<code class="highlighter-rouge">forward_list</code>或一个流迭代器创建反向迭代器。</p>

<h2 id="泛型算法结构">泛型算法结构</h2>

<p><strong>迭代器类别</strong>:</p>

<ul>
  <li><strong>输入迭代器</strong>：<code class="highlighter-rouge">==</code> <code class="highlighter-rouge">！=</code> <code class="highlighter-rouge">++</code> <code class="highlighter-rouge">*</code> <code class="highlighter-rouge">-&gt;</code> 不保迭代器状态。</li>
  <li><strong>输出迭代器</strong>：<code class="highlighter-rouge">++</code> <code class="highlighter-rouge">*</code> 只能赋值一次。</li>
  <li><strong>前向迭代器</strong>：输入和输出迭代器的操作，多次读写，多遍扫描。</li>
  <li><strong>双向迭代器</strong>：前置和后置递减运算符(<code class="highlighter-rouge">--</code>)。</li>
  <li><strong>随机访问迭代器</strong>：常量时间访问序列，(<code class="highlighter-rouge">&lt;</code> <code class="highlighter-rouge">&lt;=</code> <code class="highlighter-rouge">&gt;</code> <code class="highlighter-rouge">&gt;=</code> <code class="highlighter-rouge">+</code> <code class="highlighter-rouge">+=</code> <code class="highlighter-rouge">-</code> <code class="highlighter-rouge">-=</code> <code class="highlighter-rouge">-</code> <code class="highlighter-rouge">[]</code>）。</li>
</ul>

<h3 id="算法形参模式">算法形参模式</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">alg</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="n">alg</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="n">alg</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">beg2</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="n">alg</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">beg2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</code></pre>
</div>

<ul>
  <li>一些算法使用重载形式传递一个谓词</li>
  <li>_if版本算法</li>
  <li>区分拷贝元素的版本和不拷贝的版本</li>
</ul>

<h3 id="特定容器算法">特定容器算法</h3>

<p>链表类型<code class="highlighter-rouge">list</code>和<code class="highlighter-rouge">forward_list</code>定义了几个成员函数形式的算法：<code class="highlighter-rouge">sort</code> <code class="highlighter-rouge">merge</code> <code class="highlighter-rouge">remove</code> <code class="highlighter-rouge">reverse</code> <code class="highlighter-rouge">unique</code>。</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">lst</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>
<span class="n">lst</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">lst2</span><span class="p">,</span><span class="n">comp</span><span class="p">)</span>
<span class="n">lst</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="n">lst</span><span class="p">.</span><span class="n">remove_if</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
<span class="n">lst</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="n">lst</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">lst</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
<span class="n">lst</span><span class="p">.</span><span class="n">unique</span><span class="p">()</span>
<span class="n">lst</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
</code></pre>
</div>

<p><strong>splice成员</strong>:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">lst</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="n">lst</span><span class="p">.</span><span class="n">splice_after</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</code></pre>
</div>
